### 第一题
fibonacci_decomposition(N, D), that takes two strictly positive integers N and D as arguments, and writes N/D as a sum of unit fractions 
following Fibonacci method, plus an integer in case N≥D (in a unique way)

shortest_length_decompositions(), that also takes two strictly positive integers N and D as arguments, and writes N/D 
as a sum of unit fractions with a minimal number of summands, plus an integer in case N ≥ D (in possibly many ways)



      from math import gcd
      def reduce(numerator, denominator:
        the_gcd = gcd(numerator, denominator)
        return numberaotr // the_gcd, denominator // the_gcd
      
      def subtract(nu, de, unit_denominator):
        nu = nu * unit_denominator - de  （其中 unit_de = de // nu + 1，n/d - 1/ud）
        de *= unit_denominator
        return reduce(nu, de)
      def fibonacci_decomposition(N ,D):
        print(f'{N}/{D} = ', end = '')
        nu, de = reduce(N,D)
        nu %= de
        if not nu:
          print(N // D)
          return
        if N > D:
          print(f'{N // D} + ', end ='')
        decomposition = []
        while de % nu :
          unit_de = de // nu + 1
          decompostion.append(unit_de)
          nu, de = subtract(nu, de, unit_de)
        decomposition.append(denominator)
        print(' + '.join(f'1/{unit_de}' for unit_de in decomposition))
      
      def shortest_length_decompositions(N, D):
            nu ,de = reduce(N, D)
            nu %= denominator
            if not numerator:
                    print(f'{N}/{D} = {N // D}')
                    return
            length = 1
            while True:
                  decompositions = fixed_length_de(length, numerator,                                                   denominator,2)
                  if decompositions:
                        for decompositions in decompositions:
                              print(f'{N}/{D}=',end='')
                              if N>D:
                                    print(f'{N // D} + ', end='')
                              print(' + '.join(f'1/{unit_denominator}'
                                     for unit_denominator in decomposition
                                            )
                                 )
                        return
                   length += 1
        def fixed_length_de(length, N, D, minimum):
            if length ==1:
                  if N == 1:
                        return[[D]]
                  return
            decompositions = []
            upper_bond = D * length // N
            if length % N:
                  upper_bond += 1
            for unit_de in range(max(D // N + 1, minimum), upper_bound):
                  nu, de = substract(N, D, unit_denominator)
                  further_decompositions = fixed_length_de(length - 1, nu, de, unit_de + 1)
                  if further_decompositions:
                        for decompositions in further_decompositions:
                              decompositions.append([unit_denominaotr] +                                    decomposition)
           return decompositions

### 第二题
